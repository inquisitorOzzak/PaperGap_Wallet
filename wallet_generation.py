from bitmerchant.wallet import *
from cryptos import *


class wallet:
    __words = ""

    def __init__(self):
        self.__valid_seed = True
        self.__wallet = Wallet.from_master_secret(self.__words)  # generates wallet based on the words
        self.__priv_key = self.__wallet.serialize_b58(private=True)  # generates extended private key
        self.__pub_key = self.__wallet.serialize_b58(private=False)  # generates extended public key

    # compares inputted seed with list of 2048 words
    def __verify_seed(self, words):
        word_list = words.split(" ")
        rel_path = "venv/bitcoin/english.txt"
        file = open(rel_path, "r")
        file_contents = file.read()
        for word in word_list:
            if word not in file_contents:
                print("invalid seed")
                self.__valid_seed = False
                file.close()
                break
        file.close()

    def gen_new_wallet(self, num):
        self.__words = entropy_to_words(os.urandom(num))

    def restore_wallet(self, words):
        self.__verify_seed(words)
        self.__words = words

    # outputs wallet attributes to user.
    # will need authentication from user like password to access
    def get_wallet(self):
        if self.__valid_seed:
            print("\nThese words are the mnemonic seed from which "
                  "the public and private extended keys "
                  "are generated \n mnemonic seed: ", self.__words)

            print("\nThis extended private key is used to generate "
                  "derived addresses and public keys which can "
                  "only be accessed by inputting the extended "
                  "private key \n Extended private key: ", self.__priv_key)

            print("\nThe extended public key is visible by all users and "
                  "is derived from the mnemonic seed \nExtended Public Key: ", self.__pub_key)

    # derives a variable amount of address/ public key pairs from extended private
    # key. If a user wants to access their wallet they shoul input the private key to
    # generate these addresses, after entering their password.
    # using .txt file as simple implementation
    def gen_derived_address(self, var):
        if self.__valid_seed:
            file = open("password.txt", "w")
            file.write("These derived addresses can only be generated by inputting the "
                       "wallets extended private key. If this is lost they cannot be "
                       "regained.\nExtended private key: " + str(self.__priv_key) + "\n\n")
            for x in range(var):
                my_wallet_children = self.__wallet.deserialize(self.__priv_key)
                child = my_wallet_children.get_child(x, is_prime=True, as_private=False)
                file.write("public key " + str(x + 1) + ":\t" + str(child.serialize(private=False)) + "\n")
                file.write("address " + str(x + 1) + ":\t" + str(child.to_address()) + "\n")
                file.write("==========================================================\n")
            file.close()


wallet1 = wallet()
wallet1.gen_new_wallet(32)
wallet1.gen_derived_address(5)
wallet1.get_wallet()

wallet2 = wallet()
wallet2.restore_wallet(
    "tip taste bundle desert illness pattern prepare hundred coil dry inhale eternal special off addict there tiger symbol")
# wallet2.get_wallet()
